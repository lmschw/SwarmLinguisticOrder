# this program allows a minimal display of the likelihood that a robot to be between its neighbours while each robot represents a letter of the English alphabet

# variables
var value = 83
var id = 0
var nextval = 0
var prevval = 0
var oldhappiness = 0
var happiness = -1

# for average of last 10 sensor readings
var lastHorizontal0readings[] = [0,0,0,0,0,0,0,0,0,0]
var lastHorizontal1readings[] = [0,0,0,0,0,0,0,0,0,0]
var lastHorizontal2readings[] = [0,0,0,0,0,0,0,0,0,0]
var lastHorizontal3readings[] = [0,0,0,0,0,0,0,0,0,0]
var lastHorizontal4readings[] = [0,0,0,0,0,0,0,0,0,0]
var lastHorizontal5readings[] = [0,0,0,0,0,0,0,0,0,0]
var lastHorizontal6readings[] = [0,0,0,0,0,0,0,0,0,0]

#
var roundPointer = 0

var i = 0

var avgH0 = 0
var avgH1 = 0
var avgH2 = 0
var avgH3 = 0
var avgH4 = 0
var avgH5 = 0
var avgH6 = 0

# for the frequencies
var prev[27]
var next[27]



# initializing the context frequencies []a. abc + space
prev[0] = 83
prev[1] = 8
prev[2] = 3
prev[3] = 4
prev[4] = 143
prev[5] = 0
prev[6] = 0
prev[7] = 0
prev[8] = 125
prev[9] = 0
prev[10] = 2
prev[11] = 3
prev[12] = 4
prev[13] = 59
prev[14] = 45
prev[15] = 4
prev[16] = 0
prev[17] = 32
prev[18] = 89
prev[19] = 3
prev[20] = 70
prev[21] = 0
prev[22] = 2
prev[23] = 0
prev[24] = 8
prev[25] = 0
prev[26] = 300

# initializing the context frequencies a[]. abc + space
next[0] = 32
next[1] = 0
next[2] = 30
next[3] = 0
next[4] = 149
next[5] = 6
next[6] = 0
next[7] = 60
next[8] = 123
next[9] = 0
next[10] = 9
next[11] = 16
next[12] = 10
next[13] = 2
next[14] = 53
next[15] = 41
next[16] = 1
next[17] = 1
next[18] = 89
next[19] = 193
next[20] = 63
next[21] = 0
next[22] = 6
next[23] = 0
next[24] = 8
next[25] = 0
next[26] = 96

# no lights
call leds.top(0,0,0)

# enable communication
call prox.comm.enable(1)

onevent prox
	# updating the last reading arrays
	lastHorizontal0readings[roundPointer] = prox.horizontal[0]
	lastHorizontal1readings[roundPointer] = prox.horizontal[1]
	lastHorizontal2readings[roundPointer] = prox.horizontal[2]
	lastHorizontal3readings[roundPointer] = prox.horizontal[3]
	lastHorizontal4readings[roundPointer] = prox.horizontal[4]
	lastHorizontal5readings[roundPointer] = prox.horizontal[5]
	lastHorizontal6readings[roundPointer] = prox.horizontal[6]
	
	# computing the average of the last 10 sensor readings for all horizontal distance sensors
	callsub average
	
	# emit the value for the others to check against
	if id !=0 then
		emit neighbour_value [id, value]
	end
	
	# if there are no neighbours, set happiness to -1
	if (avgH2 < 10 and avgH2 > -10)  and ((avgH5 < 10 and avgH5 > -10) or (avgH6 < 10 and avgH6 > -10)) then
		happiness = -1
		nextval = 0
		prevval = 0
	elseif  (avgH2 < 10 and avgH2 > -10)  then
		nextval = 0
	elseif ((avgH5 < 10 and avgH5 > -10) or (avgH6 < 10 and avgH6 > -10))  then
		prevval = 0
	end
	
	# call the subroutine to establish the IDs
	callsub establishIDs
	
	callsub happycheck

	if happiness == -1 then
		call leds.top(32,32,32)
	elseif  happiness > 200 then
		call leds.top(0,32,0)
		if oldhappiness <= 200 then
			call sound.system(7)
		end
	elseif  happiness > 100 then
		call leds.top(32,32,0)
		if oldhappiness > 200 or oldhappiness <= 100 then
			call sound.system(6)
		end
	else
		call leds.top(32,0,0)
		if oldhappiness > 100 then
			call sound.system(4)
		end
	end	

onevent neighbour_value
	if id != 0 then
		if event.args[0] == id-1 then
			prevval = event.args[1]
		elseif  event.args[0] == id+1 then
			nextval = event.args[1]
		end
	end
	
sub happycheck
 # if the robot has two neighbours, it does the sum.
 # if the robot only has one neighbour, the other side is considered an empty space
 # if the robot does not have neighbours, happiness = -1
 	oldhappiness = happiness
 	if prevval != 0 and nextval != 0 then
 		happiness = prev[prevval-65] + next[nextval-65]
 	elseif nextval != 0 then
 		happiness = prev[26] + next[nextval-65]
 	elseif prevval != 0 then
 		happiness = prev[prevval-65] + next[26]
 	else
 		happiness = -1
 	end

# BOTTOM LAYER COMMUNICATION
sub establishIDs
	# if no neighbour behind but neighbour in front, ID = 1
	if id == 0 and ((avgH5 < 10 and avgH5 > -10) or (avgH6 < 10 and avgH6 > -10)) and (avgH2 > 10 or avgH2 < -10) then
		id = 1
		# send out the robot's ID
		prox.comm.tx = id
	# if ID != 1 and no neighbours behind or if ID == 1 and neighbours behind, re-establish the IDs
	elseif( id != 1 and ((avgH5 < 10 and avgH5 > -10) or (avgH6 < 10 and avgH6 > -10))) or (id == 1 and ((avgH5 > 10 and avgH5 < -10) or (avgH6 > 10 and avgH6 < -10))) then
		id = 0
		emit recountID
	end


onevent prox.comm
	# if the robot does not have an ID yet and it receives a message, it increments the senderID and stores it as its own
	if  id == 0 and prox.comm.rx != 0 then
		id = prox.comm.rx + 1
		# send out the robot's ID
		prox.comm.tx = id
	# if the robot has an ID but receives an unexpected ID, the IDs need to be re-established as it is likely that the order has changed
	elseif id != 0 and prox.comm.rx != (id-1) and prox.comm.rx != (id+1) then
		id = 0
		emit recountID
	end
	
# set ID back to 0 and pass the message on
onevent recountID
	if id != 0 then
		id = 0
		# send out the robot's ID
		prox.comm.tx = id
		emit recountID
	end

# computing the averages of all horizontal proximity sensor valules
sub average
	avgH0 = 0
	avgH1 = 0
	avgH2 = 0
	avgH3 = 0
	avgH4 = 0
	avgH5 = 0
	avgH6 = 0
	i = 0
	while i < 10 do
		avgH0 += lastHorizontal0readings[i]
		avgH1 += lastHorizontal1readings[i]
		avgH2 += lastHorizontal2readings[i]
		avgH3 += lastHorizontal3readings[i]
		avgH4 += lastHorizontal4readings[i]
		avgH5 += lastHorizontal5readings[i]
		avgH6 += lastHorizontal6readings[i]
		i++
	end
	avgH0 = avgH0/10
	avgH1 = avgH1/10
	avgH2 = avgH2/10
	avgH3 = avgH3/10
	avgH4 = avgH4/10
	avgH5 = avgH5/10
	avgH6 = avgH6/10