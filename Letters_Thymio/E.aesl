<!DOCTYPE aesl-source>
<network>


<!--list of global events-->


<!--list of constants-->
<constant value="69" name="value"/>


<!--show keywords state-->
<keywords flag="true"/>


<!--node thymio-II-->
<node nodeId="1" name="thymio-II"># variable declarations
var prev[27]
var next[27]
var happiness = 0 # how happy the robot is in its current position
var change = 0 # used as boolean. has anything been changed?
var before = -1 # value of the robot behind
var after = -1 # value of the robot in front
var t0period = 500
var restperiod = 100
var moveperiod = 300
var direction = 0 # 0 for right, 1 for left
call prox.comm.enable(1)

# ONLY THIS PART IS LETTER SPECIFIC
# initializing the context frequencies []a. abc + space
prev[0] = 0
prev[1] = 19
prev[2] = 55
prev[3] = 65
prev[4] = 25
prev[5] = 19
prev[6] = 34
prev[7] = 40
prev[8] = 22
prev[9] = 3
prev[10] = 15
prev[11] = 69
prev[12] = 55
prev[13] = 47
prev[14] = 2
prev[15] = 40
prev[16] = 0
prev[17] = 137
prev[18] = 68
prev[19] = 105
prev[20] = 13
prev[21] = 64
prev[22] = 14
prev[23] = 0
prev[24] = 6
prev[25] = 5
prev[26] = 67

# initializing the context frequencies a[]. abc + space
next[0] = 64
next[1] = 2
next[2] = 39
next[3] = 26
next[4] = 25
next[5] = 14
next[6] = 13
next[7] = 2
next[8] = 6
next[9] = 0
next[10] = 2 
next[11] = 49
next[12] = 28 
next[13] = 117
next[14] = 2
next[15] = 15
next[16] = 5
next[17] = 148 
next[18] = 65
next[19] = 35
next[20] = 0
next[21] = 17
next[22] = 6 
next[23] = 21
next[24] = 4 
next[25] = 0
next[26] = 279

timer.period[0] = t0period
timer.period[1] = restperiod

# this subroutine updates the happiness value of the robot according to its neighbours and if any changes have been made to those neighbours. If the happiness value has already been below 100 before, the robot moves away

sub happycheck
 if change == 0 then
 if happiness > 100  then
 	happiness = happiness-20
 else
 	motor.left.target = 200
 	motor.right.target = 200
 end
 # if the robot has two neighbours, it does the sum.
 # if the robot only has one neighbour, the other side is considered an empty space
 # if the robot does not have neighbours, happiness = 0	
 else
 	if before != -1 and after != -1 then
 		happiness = prev[before-65] + next[after-65]
 	elseif after != -1 then
 		happiness = prev[26] + next[after-65]
 	elseif before != -1 then
 		happiness = prev[before-65] + next[26]
 	else
 		happiness = 0
 	end
 end
 
 # blue if no neighbours, red if unhappy enough to walk away, yellow if unhappy but okay, green if happy
 if happiness == 0 then
 	call leds.top(0,0,32)
 elseif happiness &lt; 100 then
 	call leds.top(32,0,0)
 elseif happiness &lt; 200 then
 	call leds.top(32,32,0)
 else
 	call leds.top(0,32,0)
 end

# when the robot receives a new value, it updates its before and after values and calls the happycheck subroutine 
onevent prox.comm
	after = prox.comm.rx
	change = 1
	callsub happycheck

# every time the timer reaches 0, the happiness value is reduced by 20 by calling the happycheck subroutine
onevent timer0
	change = 0
	callsub happycheck

# timer1 does the direction discrimination. It makes sure that only one robot is close enough to communicate by slowly oscillating between two poles: right and left	
onevent timer1
	if timer.period[1] == restperiod then
		if direction == 0 then
			motor.left.target = -200
			motor.right.target = -200
			direction = 1
		else
			motor.left.target = 200
			motor.right.target = 200
			direction = 0
		end
		timer.period[1] = moveperiod
	else
		motor.left.target = 0
		motor.right.target = 0
		timer.period[1] = restperiod
	end</node>


</network>
