#NICE
# ADJECTIVE

#----------------------------------------------------------------------------I N I T----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------BEGIN INITIALISATION-------------------------------------------------------------------------------

#---------------------------------------------------------------------------variables--------------------------------------------------------------------------------------------------
# word-specific values
var value[] = [70,65,83,84] 			# the ASCII code every letter of the word as an array - 'fast'
var class = 7								# category - adjective  in this case
var coreclass = 1			# if the class is the core of a phrase

# grammaticality judgements
var maxclass = 104	# maximal phrase category achieved, e.g. NP, VP, construction etc.
var phraseID = 0			# id of the phrase containing the word
var phrasetype = 104		# type of the phrase corresponding to the phraseID
var oldphraseID = 0	# if superceding phrase, used to notify all other members of the same phrase
var phraseComplete = 1	# if the phrase is complete
var constructionComplete = 0	# if the whole construction is complete
#var phraseIDsInPhrase[4]	# where the IDs of all absorbed phrases are stored
var highestpid = 0	# highest phraseID below the current robot
var phrasestart = -1
var phraseend = -1
var phrasecore = -1
var updateComplete = 1
var upscalable = 0		# is another increment possible?
var updateSuccessful = 0
var higherPhrase = 0	# does the robot belong to another phrase
var cu = 0		# keep sending out checkupdate events?
var bl = 0			# keep sending out the block event?
var lastPhraseAddition = 0	# ID of the core of the last phrase added

# storage variables
var consPossible[4] = [1,1,0,0]
var adjpPossible[] = [0,1,1,1]
var adjpLengths [] = [1,2,3,3]

# general variables
var id = 0 					# the communication ID. Corresponds to the number of the robot in the line starting from the backhigh
var oldid = 0				# to check if there has been a change in the order
var pid = 0					# underlying phrase id
var oldpid = 0				# to check if there has been a change in the pid

# aux variables
#var prevback = 0
#var prevfront = 0
var bool = 0
var i = 0
var j = 0

# completion check variables
var adjp1comp[] = [class,0]
var adjp2comp[] = [class,0,0]
var adjp3comp[] = [maxclass,0,0]

#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------constructions-------------------------------------------------------------------------------------------------
# constructions: 100
var c0[] = [102]	# VP
var c1[] = [105]	# ADVP
var c2[] = [100,14,100]	# construction + CONJ + construction
var c3[] = [100,15,100]	# construction + SUB + construction

# NPs: 101
var np0[] = [8,1]		# DET + N
var np1[] = [8,104,1]	# DEP+ ADJP + N
var np2[] = [9]	# PRO

# VPs: 102
var vp0[] = [101,2]		# NP + intransV
var vp1[] = [101,3,101]	# NP + transV + NP
var vp2[] = [101,16,101,101]	# NP + transV2 + NP + NP
var vp3[] = [101,4,104]	# NP + be + ADJP
var vp4[] = [101, 2,103]	# NP + intransV + PP
var vp5[] = [101,3,101,103]	# NP + transV + NP + PP
var vp6[] = [101,16,101,101,103]	# NP + transV2 + NP + NP + PP
var vp7[] = [101,17,10,2]	# NP + do + NEG + intransV
var vp8[] = [101,17,10,3,101]	# NP + do + NEG + transV + NP
var vp9[] = [101,17,10,16,101,101]	# NP + do + NEG + transV2 + NP + NP
var vp10[] = [101,17,10,2,103]	# NP + do + NEG + intransV + PP
var vp11[] = [101,17,10,3,101,103]	# NP + do + NEG + transV + NP + PP
var vp12[] = [101,17,10,16,101,101,103]	#NP + do + NEG + transV2 + NP + NP + PP

# PPs: 103
var pp0[] = [11,101]	# P + NP
var pp1[] = [103,103]	# PP + PP
var pp2[] = [103,14,103]	# PP + CONJ + PP

# ADJP: 104
var adjp0[] = [7]	# ADJ
var adjp1[] = [7,104]	# ADJ + ADJP
var adjp2[] = [7,14,104]	# ADJ + CONJ + ADJP
var adjp3[] = [104,14,104]	# ADJP + CONJ + ADJP

# ADVP:105
var advp0[] = [102,13]	# VP + ADV

#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------functions----------------------------------------------------------------------------------------------------

# resetting the leds so that no previous colour setting interferes
call leds.top(0,0,0)

# enabling communication
call prox.comm.enable(1)

timer.period[0] = 2000

#----------------------------------------------------------------------------END INITIALISATION----------------------------------------------------------------------------------

onevent prox	
	
	oldid = id
	oldpid = pid
	
	# call the subroutine to establish the IDs
	callsub establishIDs
	callsub establishPhraseIDs
	
	if oldid != id and oldpid != pid then
		callsub reset
	end
	
	emit neighbour_value [id, highestpid]
	
	if higherPhrase != 1 then
		phraseID = pid
		if coreclass == 1 then
			phrasestart = id
			phraseend = id
		else
			phrasestart = -1
			phraseend = -1
		end
	end
		
	#TODO what I need
	if id != 0 and phraseID != 0 and (maxclass == 104 or maxclass == 7) and upscalable == 0 then
			emit searchNextCompletion [id, phraseID, phraseend, 	phrasetype]
	end
	#TODO end
	
	if cu == 1 or updateComplete == 0 then
		if phraseend != -1 and phraseend != 0 then
		
			emit checkUpdate [id, phrasecore, maxclass, phraseend]
		else
			emit checkUpdate [id, phrasecore, maxclass, id]
		end
	end

	
	if updateSuccessful == 1 and lastPhraseAddition != 0 then
		emit successfulUpdateConfirmation [id, lastPhraseAddition, phraseID, phrasetype, phraseComplete, upscalable]
	end
	
		if bl == 1 then
		emit block [id, phrasecore, maxclass]
	end
	
	
	if constructionComplete == 1 then
		emit constructionComplete [phraseID]
	elseif phraseComplete == 1 then
		emit phraseComplete [phraseID, upscalable]
	end
	
	if phraseComplete == 1 and (prox.horizontal[2] < 10 and prox.horizontal[2] > -10) and  ((prox.horizontal[5] > 10 or prox.horizontal[6] < -10) or (prox.horizontal[6] > 10 or prox.horizontal[6] < -10)) then
		upscalable = 1
	end

	
	# if there are no neighbours, set colour to white
	if (prox.horizontal[2] < 10 and prox.horizontal[2] > -10)  and ((prox.horizontal[5] < 10 and prox.horizontal[6] > -10) or (prox.horizontal[6] < 10 and prox.horizontal[6] > -10)) then
		id = 0
		pid = 0
		upscalable = 0
		callsub reset
		call leds.top(32,32,32)
	elseif constructionComplete == 1 then
		call leds.top(0,32,0)
	elseif phraseComplete == 1 then
		call leds.top(32,32,0)
	elseif id != 0 then
		call leds.top(32,0,0)
	else
		call leds.top(32,32,32)
	end


#-----------------------------------------------------------------------C O M M U N I C A T I O N----------------------------------------------------------------------------------
#-----------------------------------------------------------------------BOTTOM LAYER COMMUNICATION------------------------------------------------------------------------
# BOTTOM LAYER COMMUNICATION
sub establishIDs
	# if no neighbour behind but neighbour in front, ID = 1
	if id == 0 and ((prox.horizontal[5] < 10 and prox.horizontal[5] > -10) or (prox.horizontal[6] < 10 and prox.horizontal[6] > -10)) and (prox.horizontal[2] > 10 or prox.horizontal[2] < -10) then
		id = 1
		# send out the robot's ID
		prox.comm.tx = id
	# if ID != 1 and no neighbours behind or if ID == 1 and neighbours behind, re-establish the IDs
	elseif( id != 1 and ((prox.horizontal[5] < 10 and prox.horizontal[5] > -10) or (prox.horizontal[6] < 10 and prox.horizontal[6] > -10)) and (prox.horizontal[2] > 10 or prox.horizontal[2] < -10)) then
		id = 1
		emit recountID
	end


onevent prox.comm
	# if the robot does not have an ID yet and it receives a message, it increments the senderID and stores it as its own
	if  id == 0 and prox.comm.rx != 0 and ((prox.horizontal[5] > 10 or prox.horizontal[5] < -10) or (prox.horizontal[6] > 10 or prox.horizontal[6] < -10)) then
		id = prox.comm.rx + 1
		# send out the robot's ID
		prox.comm.tx = id
	# if the robot has an ID but receives an unexpected ID, the IDs need to be re-established as it is likely that the order has changed
	elseif id != 0 and prox.comm.rx != (id-1) and prox.comm.rx != (id+1) and prox.comm.rx != 0 then
		if id != 1 or ((prox.horizontal[5] > 10 or prox.horizontal[5] < -10) or (prox.horizontal[6] > 10 and prox.horizontal[6] < -10)) then
			id = 0
		end
		prox.comm.tx = id
		emit recountID
	end
	
# set ID back to 0 and pass the message on
onevent recountID
	pid = 0
	callsub reset
	if ((prox.horizontal[5] < 10 and prox.horizontal[5] > -10) or (prox.horizontal[6] < 10 and prox.horizontal[6] > -10)) and (prox.horizontal[2] > 10 or prox.horizontal[2] < -10) then
		if id != 1 then
			id = 1
			# send out the robot's ID
			prox.comm.tx = id
		end

	elseif  id > 1 then
		id = 0
		# send out the robot's ID
		prox.comm.tx = id
	end


#-------------------------------------------------------------------------TOP LAYER COMMUNICATION--------------------------------------------------------------------------------
# TOP LAYER COMMUNICATION
sub establishPhraseIDs
	if pid == 0 and ((prox.horizontal[5] < 10 and prox.horizontal[5] > -10) or (prox.horizontal[6] < 10 and prox.horizontal[6] > -10)) and (prox.horizontal[2] > 10 or prox.horizontal[2] < -10) then
		if class != 1 and class != 10 and class != 12 and class != 14 then
			pid = 1
			highestpid = 1
			emit neighbour_value [id, pid]
		else
			pid = -2
			emit neighbour_value [id, 0]			
		end
	else
		emit neighbour_value [id, highestpid]
	end

# neighbour_value [id{0}, maxphraseid{1}]
onevent neighbour_value
	if id == event.args[0]+1 then
		if class != 1 and class != 10 and class != 12 and class != 14 then
			pid = event.args[1] + 1
			highestpid = pid
			emit neighbour_value [id, pid]
		else
			pid = -2
			highestpid = event.args[1]
			emit neighbour_value [id, highestpid]
		end	
	end
	
#-----------------------------------------------------------------G R A M M A T I C A L I T Y    J U D G E M E N T S----------------------------------------------------------------
#-----------------------------------------------------------------SEARCH EVENTS------------------------------------------------------------------------------------------------------
# adjectives on their own can only be part of an ADJP and they will be the core of that phrase. If they already form an ADJP, they can only become part of another ADJP, a NP or a VP. In all other cases, the adjective notifies the sender that there will not be a completion including the adjective.
#	emit searchNextCompletion [id{0}, phraseID{1}, phraseend{2}, 	phrasetype{3}]
onevent searchNextCompletion
		if  phraseID != event.args[1] and maxclass == 104 and upscalable == 1 and  updateComplete == 1 and (event.args[3] ==  101 or event.args[3] == 102 or event.args[3] == 104)  and event.args[2] == id-1 then
		phrasecore = event.args[0]
		updateComplete = 0
		cu = 1
		bl = 0
		if phraseend != -1  and phraseend != 0 then
			emit checkUpdate [id, phrasecore, maxclass, phraseend]
		else
			emit checkUpdate [id, phrasecore, maxclass, id]
		end
	elseif phraseID != event.args[1] and event.args[2] == id-1 and  (event.args[3] !=  101 and event.args[3] != 102 and event.args[3] != 104 )then
		phrasecore = event.args[0]
		bl = 1
		emit block [id, phrasecore, maxclass]
	end
	
onevent searchPrevCompletion
	if  phraseID != event.args[1] and maxclass > 99 and upscalable == 1 and  updateComplete == 1 and (event.args[3] ==  102)  and event.args[2] == id+1 then
		emit searchPrevCompletion [event.args[0], event.args[1], id, event.args[3]]
	end

#----------------------------------------------------------------UPDATES----------------------------------------------------------------------------------------------------------------
# if a robot sends back a message, the robot checks if the new value should be included in the phrase
# ADJP: 104
#var adjp0[] = [7]	# ADJ
#var adjp1[] = [7,104]	# ADJ + ADJP
#var adjp2[] = [7,14,104]	# ADJ + CONJ + ADJP
#var adjp3[] = [104,14,104]	# ADJP + CONJ + ADJP
#
#
## completion check variables
#var adjp1comp[] = [class,0]
#var adjp2comp[] = [class,0,0]
#var adjp3comp[] = [maxclass,0,0]
#	emit checkUpdate [id{0}, phrasecore{1}, maxclass{2}, phraseend{3}]
onevent checkUpdate
	if event.args[0] == phraseend + 1 then
		updateSuccessful = 0
		if event.args[2] == 14 and adjp2comp[1] == 0 and adjp3comp[1] == 0 then
			adjp2comp[1] = 14
			adjp3comp[1] = 14
			adjpPossible[1] = 0
			phraseComplete = 0
			upscalable = 0
			updateSuccessful = 1
		elseif event.args[2] == 104 then
			if adjpPossible[1] == 1 and adjp1comp[1] == 0 then
				adjp1comp[1] = 104
				adjpPossible[1] = 0
				adjpPossible[2] = 0
				adjpPossible[3] = 0
				phraseComplete = 1
				upscalable = 1
				maxclass = 104
				updateSuccessful = 1		
			elseif adjpPossible[2] ==1 and adjpPossible[3] == 1 and adjp2comp[1] == 14 and adjp2comp[2] == 0 and adjp3comp[1] == 14 and adjp3comp[2] == 0 then
				adjpPossible = [0,0,0,0]
				adjp2comp[2] = 104
				adjp3comp[2] = 104
				phraseComplete = 1
				maxclass = 104
				updateSuccessful = 1
				upscalable = 1
			end
		end
		if updateSuccessful == 1 then
			higherPhrase = 1
			phraseend = event.args[3]
			lastPhraseAddition = event.args[0]
			emit successfulUpdateConfirmation [id, event.args[0], phraseID, phrasetype, phraseComplete, upscalable]
			if phraseComplete == 1 then
				emit phraseComplete [phraseID, upscalable]
			end
		else
			if phraseComplete == 1 then
				upscalable = 1
				maxclass = phrasetype
			else
				upscalable = 0
			end
			emit updateDeclination [id, event.args[0]]
		end
	end

# if the robot's phrase is absorbed, the supercede event informs it of the update
# emit supercede [id{0}, oldphraseID{1}, phraseID{2}, phrasetype{3}, phraseComplete{4}, upscalable{5}]
onevent supercede
	if event.args[1] == phraseID then
		oldphraseID = phraseID
		phraseID = event.args[2]
		phrasetype = event.args[3]
		if event.args[4] == 1 then
			phraseComplete = 1
			maxclass = phrasetype
		else
			phraseComplete = 0
		end
		if event.args[5] == 1 then
			upscalable = 1
		else
			upscalable = 0
		end
	end
	
# emit phraseComplete [phraseID, upscalable]
onevent phraseComplete
	if event.args[0] == phraseID then
		phraseComplete = 1
		upscalable = event.args[1]
	end
	
# emit constructionComplete [phraseID]
onevent constructionComplete
	if event.args[0] == phraseID then
		constructionComplete = 1
		upscalable = 1
	end

#	emit block [id, phrasecore, maxclass]	
onevent block
	if event.args[1] == id and event.args[0] == phraseend + 1 then
		if phraseComplete == 1 then
			upscalable = 1
			maxclass = phrasetype
		else
			upscalable = 0
		end
	end
	
#-------------------------------------------------------------RESPONSES------------------------------------------------------------------------------------------------------------------
#	emit successfulUpdateConfirmation [id{0}, event.args[0]{1}, phraseID{2}, phrasetype{3}, phraseComplete{4}, upscalable{5}]
# if the phrasecore confirms the update, the robot updates its own data
onevent successfulUpdateConfirmation
	if event.args[0] == phrasecore and event.args[1] == id  and phraseID != event.args[2] then
		cu = 0
		bl = 0
		higherPhrase = 1
		updateComplete = 1
		oldphraseID = phraseID
		phraseID = event.args[2]
		phrasetype = event.args[3]
		if event.args[4] == 1 then
			phraseComplete = 1
			maxclass = event.args[3]
		else
			phraseComplete = 0
		end
		if event.args[5] == 1 then
			upscalable = 1
		else
			upscalable = 0
		end
		emit supercede [id, oldphraseID, phraseID, phrasetype, phraseComplete, upscalable]
	end

#if the phrasecore declines the update, the robot switches back into considering other search events
#	emit updateDeclination [senderid, targetid]
onevent updateDeclination
	if event.args[0] == phrasecore and event.args[1] == id then
		cu = 0
		phrasecore = 0
		updateComplete = 1
	end
	
#----------------------------------------------------------------R E S E T T I N G-----------------------------------------------------------------------------------------------------
sub reset
	adjp1comp = [class,0]
	adjp2comp = [class,0,0]
	adjp3comp = [0,0,0]
	consPossible = [1,1,0,0]
	adjpPossible = [0,1,1,1]
	constructionComplete = 0
	phraseComplete = 1
	updateSuccessful = 0
	cu = 0
	maxclass = 104
	phraseID = 0
	oldpid = 0
	oldid = 0
	highestpid = 0
	pid = 0
	phrasetype = 104		# type of the phrase corresponding to the phraseID	
	oldphraseID = 0
	upscalable = 0
	phrasestart = 0
	phraseend = 0
	phrasecore = 0
	higherPhrase = 0
	updateComplete = 1
	bl = 0