# this program allows the robot to decide how happy it is with the position the user puts it in with regards to the values assigned to its neighbours. If it is not happy, it will
# walk off after a while - SIMPLE GRAMMAR
# class: DETERMINER

# TODO before each use, adjust the colour for the forward button to disambiguate the robots
# TODO before each use, set up events: neighbourInfo (2 arguments: ID, phraseID) 
# searchNPCompletion (7 args: id, phraseID,  phrasestart, phraseend, np0-1)
# searchVPCompletion (17 args: id, phraseID, phrasestart, phraseend, vp0-12)
# searchPPCompletion (7 args: id, phraseID, phrasestart, phraseend, pp0-2)
# searchADJPCompletion (9 args: id, phraseID, phrasestart, phraseend, adjp0-4)
# searchADVPCompletion (5 args: id, phraseID, phrasestart, phraseend,advp0)
# searchConsCompletion (5 args: id, phraseID, phrasestart, phraseend,cons0,cons1,cons2,cons3)


# phraseComplete(2 args: phraseID, phrasetype)
# updatePhraseBoundary(5 args: id, phraseID, maxclass, border[bool])
# supercede(4 args: id, oldPhraseID, newPhraseID, phrasetype)
# constructionComplete(0 args)

# recountID(0 args)
# recountPhraseID (0 args)

#idModeSwitch (1 arg: mode)




#TODO use prox.comm to establish the phraseIDs: certain classes get their own pID to start with: P, V, ADV, ADJ, PRO, CONJ, SUB 
#TODO emit the events when necessary and only do something if it is either a neighbour or the same phraseID
# for different words, only value and class need to be changed

#----------------------------------------------------------------------------I N I T----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------BEGIN INITIALISATION-------------------------------------------------------------------------------

#---------------------------------------------------------------------------variables--------------------------------------------------------------------------------------------------
# word-specific values
var value[] = [84,73,69] 			# the ASCII code every letter of the word as an array - 'the'
var class = 8								# category - determiner in this case

# grammaticality judgements
var maxclass = class	# maximal phrase category achieved, e.g. NP, VP, construction etc.
var phraseid = 0			# id of the phrase containing the word
var phrasetype = 0		# type of the phrase corresponding to the phraseID
var oldPhraseID = 0	# if superceding phrase, used to notify all other members of the same phrase
var phraseComplete = 0	# if the phrase is complete
var constructionComplete = 0	# if the whole construction is complete
#var phraseIDsInPhrase[4]	# where the IDs of all absorbed phrases are stored
var idpid = 0 # 0 when establishing IDs, 1 when establishing phraseIDs
var highestpid = 0	# highest phraseID below the current robot
var phrasestart = -1
var phraseend = -1

# storage variables
var consPossible[4] = [1,1,0,0]
var npPossible[3] = [1,1,1]
var npLengths [3] = [2,3,1]


# general variables
var id = 0 					# the communication ID. Corresponds to the number of the robot in the line starting from the back

# aux variables
#var prevback = 0
#var prevfront = 0
var bool = 0
var i = 0
var j = 0

# completion check variables
var np0comp[] = [class,0]
var np1comp[] = [class,0,0]
var np2comp[] = [0]

#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------constructions-------------------------------------------------------------------------------------------------
# constructions: 100
var c0[] = [102]	# VP
var c1[] = [105]	# ADVP
var c2[] = [100,14,100]	# construction + CONJ + construction
var c3[] = [100,15,100]	# construction + SUB + construction

# NPs: 101
var np0[] = [8,1]		# DET + N
var np1[] = [8,104,1]	# DEP+ ADJP + N
var np2[] = [9]	# PRO

# VPs: 102
var vp0[] = [101,2]		# NP + intransV
var vp1[] = [101,3,101]	# NP + transV + NP
var vp2[] = [101,16,101,101]	# NP + transV2 + NP + NP
var vp3[] = [101,4,104]	# NP + be + ADJP
var vp4[] = [101, 2,103]	# NP + intransV + PP
var vp5[] = [101,3,101,103]	# NP + transV + NP + PP
var vp6[] = [101,16,101,101,103]	# NP + transV2 + NP + NP + PP
var vp7[] = [101,17,10,2]	# NP + do + NEG + intransV
var vp8[] = [101,17,10,3,101]	# NP + do + NEG + transV + NP
var vp9[] = [101,17,10,16,101,101]	# NP + do + NEG + transV2 + NP + NP
var vp10[] = [101,17,10,2,103]	# NP + do + NEG + intransV + PP
var vp11[] = [101,17,10,3,101,103]	# NP + do + NEG + transV + NP + PP
var vp12[] = [101,17,10,16,101,101,103]	#NP + do + NEG + transV2 + NP + NP + PP

# PPs: 103
var pp0[] = [11,101]	# P + NP
var pp1[] = [103,103]	# PP + PP
var pp2[] = [103,14,103]	# PP + CONJ + PP

# ADJP: 104
var adjp0[] = [7]	# ADJ
var adjp1[] = [7,7]	# ADJ + ADJ
var adjp2[] = [7,104]	# ADJ + ADJP
var adjp3[] = [7,14,104]	# ADJ + CONJ + ADJP
var adjp4[] = [104,14,104]	# ADJP + CONJ + ADJP

# ADVP:105
var advp0[] = [102,13]	# VP + ADV

#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------functions----------------------------------------------------------------------------------------------------

# resetting the leds so that no previous colour setting interferes
call leds.top(0,0,0)

# enabling communication
call prox.comm.enable(1)


#----------------------------------------------------------------------------END INITIALISATION----------------------------------------------------------------------------------

# this event is launched regularly, therefore its contents are also checked and executed at a regular frequency
onevent prox
	#/////////////////////////////////////////////////////////////////////////Communication ///////////////////////////////////////////////////////////////////////////////////////////
	if constructionComplete == 1 then
		emit constructionComplete [id,phraseid]
	elseif phraseComplete == 1 then
		emit phraseComplete [id,phraseid]
	end
	if idpid ==1 then
		if id == 0 then
			idpid = 0
			emit recountID
			callsub comm
		elseif phraseid == 0 and  class != 1 and class != 10 and class != 12 then
			#phraseid = -1
			callsub comm
		else
			if phraseid > 0 then
				emit neighbour_value [id, phraseid]
			elseif  phraseid == -2 then
				emit neighbour_value [id, highestpid]
			end
		end
	end
	# if there are no neighbours, the ID, the phraseID and the mode are reset to 0
	if prox.horizontal[2] == 0 and prox.horizontal[5] == 0 and prox.horizontal[6] == 0 then
		idpid = 0
		id = 0
		callsub reset
		phraseid = 0
	# if there is only a neighbour in front and the robot was not previously the first robot in the line, the IDs are reestablished
	elseif prox.horizontal[5] == 0 and prox.horizontal[6] == 0 and id != 1 then
		emit recountID
		callsub reset
		callsub comm
	elseif  prox.horizontal[5] == 0 and prox.horizontal[6] == 0 and (phraseid != 1 and phraseid != -2) then
		if class != 1 and class != 10 and class != 12  then
			phraseid = 1
			callsub reset
			emit recountPhraseID
		else
			phraseid = -2
			callsub reset
			emit recountPhraseID
		end
	# if there is no robot in front but a neighbour at the back, the mode is switched and the other robots are alerted to do the same.
	elseif prox.horizontal[2] == 0 then
		if idpid == 0 and id != 0 then
			idpid = 1
			emit idModeSwitch idpid
		elseif idpid == 1 and phraseid >= 0 then
			idpid = 0
			emit idModeSwitch idpid
		end
	end
	
	# if the robot does not have an ID, enforces ID search. Else, checks if the robot is at the centre of a phrase or not.
	if idpid == 0 then
		if id == 0 then
			callsub comm
		end
	end
	#////////////////////////////////////////////////////////////////////////sending out the requests////////////////////////////////////////////////////////////////
# TODO req	
	# If the NP is not complete yet, send out a message asking for completion. Keep sending until no larger NP is possible
	# searchNPCompletion (7 args: id, phraseID, phraseposition, phrasestart, phraseend, np0-1)
	if phraseComplete != 0 or npPossible[0] == 1 or npPossible[1] == 1 then
		emit searchNPCompletion [id, phraseid,phrasestart, phraseend, npPossible]	
	end
# TODO req end
	#/////////////////////////////////////////////////////////////////////updating the colour////////////////////////////////////////////////////////////////////////
	if constructionComplete == 1 then
		call leds.top(0,32,0)
	elseif phraseComplete == 1 then
		call leds.top(32,32,0)
	elseif id != 0 then
		call leds.top(32,0,0)
	else
		call leds.top(32,32,32)
	end

# only does something if the robot is the first robot in the line, i.e. does not have a neighbour behind it
sub comm
	if prox.horizontal[2] > 2000 and (prox.horizontal[5] == 0 or prox.horizontal[6] == 0) then
		# if the IDs are being established, the ID of the last robot is 1 and it starts broadcasting its ID
		if idpid == 0 then
			id = 1
			prox.comm.tx = id

		# if the PhraseIDs are being established, the PhraseID of the last robot is 1 and it starts broadcasting its PhraseID
		elseif  idpid == 1 then
			phraseid = 1
			callsub reset
			emit neighbour_value [id, phraseid]
			emit recountPhraseID
		end
#	elseif  idpid == 1 and phraseid == 0 and  class != 1 and class != 10 and class != 12 then
#			phraseid = -1
	elseif  idpid == 0 then
		id = 0
	elseif  idpid ==1 then
		phraseid = 0
	end

# switches between the two modes: establishing IDs and establishing phraseIDs
onevent idModeSwitch
	if event.args[0] == 0 and (phraseid == -1 or phraseid == 0) then
		idpid = 1
		phraseid = 0
		callsub comm
	elseif event.args[0] == 1 and id == 0 then
		emit recountID
		idpid = 0
	else
		idpid = event.args[0]
	end

# establish IDs
onevent prox.comm
	# when establishing the IDs, the robot takes the value it receives as the ID of its predecessor and increments it for its own ID. Then, it broadcasts its own ID
	if idpid == 0 then
		if id == 0 and prox.comm.rx != 0 then
			id = prox.comm.rx + 1
			prox.comm.tx = id
		elseif id != prox.comm.rx -1 and id != prox.comm.rx +1 then
			emit recountID
			callsub reset
		end
	# when establishing the PhraseIDs, if the robot is at the centre of its own phrase, it increments the value and sends out its own phraseID. Else, it just passes the last phraseID on
	end
	
# establish phraseIDs
onevent neighbour_value
	if event.args[0] == id -1 then
		if phraseid == 0 and  class != 1 and class != 10 and class != 12 then
			phraseid = event.args[1] + 1
			callsub reset
			emit neighbour_value [id, phraseid]
		elseif phraseid == 0 then
			phraseid = -2
			callsub reset
			emit neighbour_value[id, event.args[1]]
			highestpid = event.args[1]
		end
	elseif (event.args[0] < id and event.args[1] > phraseid) and (event.args[0] > id and event.args[1] < phraseid) then
		emit recountPhraseID
		callsub reset
	end
	
# notifies robots that the IDs need to be reestablished
onevent recountID # takes 0 arguments
	#id = 0
	idpid = 0
	callsub comm
	
# notifies robots that the IDs need to be reestablished	
onevent recountPhraseID
	phraseid = 0
	idpid = 1
	callsub comm
	
# searchADJPCompletion (10 args: id, phraseID, phrasestart, phraseend, adjp0-4)
# there is no chance that a determiner on any level will fill in an ADJP. Therefore, searchADJPCompletion does not need to be handled

# searchADVPCompletion (5 args: id, phraseID, phrasestart, phraseend, advp0)
# a determiner can only occur in an adverbial phrase if it is part of a VP
onevent searchADVPCompletion
	if phraseid == event.args[1] then
		emit searchADVPCompletion event.args[0:4]
	elseif maxclass == 102 and event.args[4] == 1 then
		if (event.args[0] < id and event.args[3]+1 == id) or  (event.args[0] > id and event.args[3]-1 == id) then
			oldPhraseID = phraseid 
			phraseid = event.args[0]
			phrasetype = 105
			if prox.horizontal[2] == 0 or (prox.horizontal[5] == 0 and prox.horizontal[6] == 0) then
				emit updatePhraseBoundary [id, phraseid, oldPhraseID, maxclass, 1]
			else
				emit updatePhraseBoundary [id, phraseid, oldPhraseID, maxclass, 0]
			end
		end
	end
	 
# searchNPCompletion (6 args: id, phraseID,  phrasestart, phraseend, np0-1)
# there is no chance that a determiner on any level will fill in another NP. Therefore, searchNPCompletion does not need to be handled

# searchPPCompletion (7 args: id, phraseID, phrasestart, phraseend, pp0-2)
# can only complete PP if maxclass is PP or NP
onevent searchPPCompletion
	if phraseid == event.args[1] then
		emit searchPPCompletion event.args[0:6]
	elseif maxclass == 101 and event.args[4] == 1 then
		if event.args[0] < id and event.args[3] + 1 == id then
			oldPhraseID = phraseid 
			phraseid = event.args[0]
			phrasetype = 103
			if prox.horizontal[2] == 0 or (prox.horizontal[5] == 0 and prox.horizontal[6] == 0) then
				emit updatePhraseBoundary [id, phraseid, oldPhraseID, maxclass, 1]
			else
				emit updatePhraseBoundary [id, phraseid, oldPhraseID, maxclass, 0]
			end
		end
	elseif maxclass == 103 and (event.args[5] == 1 or event.args[6] == 1) then
		if (event.args[0] < id and event.args[3] + 1 == id) or (event.args[0] > id and event.args[2] -1 == id) then
			oldPhraseID = phraseid 
			phraseid = event.args[0]
			phrasetype = 103
			if prox.horizontal[2] == 0 or (prox.horizontal[5] == 0 and prox.horizontal[6] == 0) then
				emit updatePhraseBoundary [id, phraseid, oldPhraseID, maxclass, 1]
			else
				emit updatePhraseBoundary [id, phraseid, oldPhraseID, maxclass, 0]
			end
		end
	end

# searchVPCompletion (17 args: id, phraseID, phrasestart, phraseend, vp0-12)
# can only complete a VP if maxclass = 101 or maxclass = 103
onevent searchVPCompletion
	bool = 0
	if phraseid == event.args[1] then
		emit searchVPCompletion event.args[0:16]
	elseif maxclass == 101 then
		# verb after the determiner
		if event.args[0] > id and event.args[2] -1 == id then
			bool = 1
		elseif event.args[0] < id and event.args[3] + 1 == id and (event.args[5] == 1 or event.args[6] == 1 or event.args[9] == 1 or event.args[10] == 1 or event.args[12] == 1 or event.args[13] == 1 or event.args[15] == 1 or event.args[16] == 1) then
			bool = 1
		end
	elseif  maxclass == 103 and event.args[0]+1 == id then
		if event.args[8] == 1 or event.args[9] == 1 or event.args[10] == 1 or event.args[14] == 1 or event.args[15] == 1 or event.args[16] == 1 then
			bool = 1
		end
	end
	if bool == 1 then
		oldPhraseID = phraseid 
		phraseid = event.args[0]
		phrasetype = 102
		if prox.horizontal[2] == 0 then
			emit updatePhraseBoundary [id, phraseid, oldPhraseID, maxclass, 1]
		else
			emit updatePhraseBoundary [id, phraseid, oldPhraseID, maxclass, 0]
		end
	end

# searchConsCompletion (5 args: id, phraseID, phrasestart, phraseend,cons0,cons1,cons2,cons3)
# only relevant when the maxclass is 100
onevent searchConsCompletion
	if phraseid == event.args[1] then
		emit searchConsCompletion event.args[0:4]
	elseif maxclass == 100 and (event.args[6] == 1 or event.args[7] == 1) and (event.args[0] < id and event.args[3] + 1 == id) or (event.args[0] > id and event.args[2] -1 == id) then
		oldPhraseID = phraseid 
		phraseid = event.args[0]
		phrasetype = 102
		if prox.horizontal[2] == 0 then
			emit updatePhraseBoundary [id, phraseid, oldPhraseID, maxclass, 1]
		else
			emit updatePhraseBoundary [id, phraseid, oldPhraseID, maxclass, 0]
		end
	end

# updatePhraseBoundary(5 args: id, phraseID, oldPhraseID, maxclass, border[bool])
onevent updatePhraseBoundary 
	if id < event.args[0] and phraseid == event.args[1] and phraseend == event.args[0]-1 then
		phraseend = event.args[0]
		if npPossible[0] == 1 then
			i = 0
			call leds.top(32,32,32)
			while (id+i) < npLengths[0] do
				if np0comp[id+i] ==  0 and np0[id+i] == event.args[3] then
					if event.args[2] == 0 then
						np0comp[id+i] = maxclass
						call leds.top(32,12,32)
					else
						np0comp[id+i] = oldPhraseID
					end
					i = 10000
				end
				i++
			end
			i = 0
			j = 1
			while i < npLengths[0] do
				if np0comp[i] == 0 then
					j = 0
				end
				i++
			end
		elseif npPossible[1] == 1 then
			i = 1
			while (id+i) < npLengths[1] do
				if np1comp[id+i] ==  0 and np1[id+i] == maxclass then
					if oldPhraseID == 0 then
						np1comp[id+i] = maxclass
					else
						np1comp[id+i] = oldPhraseID
					end
					i = 10000
				end
				i++
			end		
			i = 0
			bool = 1
			while i < npLengths[1] do
				if np1comp[i] == 0 then
					bool = 0
				end
				i++
			end
		end
		if j == 1 or bool == 1 then
				phraseComplete = 1
				emit phraseComplete [phraseid, phrasetype]
				maxclass = phrasetype
		end
	end

#phraseComplete
onevent phraseComplete
	if phraseid == event.args[0] then
		phraseComplete = 1
		phrasetype = event.args[1]
		maxclass = phrasetype
		emit phraseComplete event.args[0:1]
	end

# constructionComplete
onevent constructionComplete
	if phraseid == event.args[0] then
		constructionComplete = 1
	end

		
sub reset
	constructionComplete = 0
	phraseComplete = 0
#	np0comp = [class,0]	
#	np1comp = [class,0,0]
#	np2comp = [0]
	consPossible = [1,1,0,0]
	npPossible = [1,1,1]
	maxclass = class
	phrasetype = 0		# type of the phrase corresponding to the phraseID	
	oldPhraseID = 0
	if phraseid > 0 then
		phrasestart = id
		phraseend = id
	else
		phrasestart = -1
		phraseend = -1
	end