# WITH
# PREPOSITION

#----------------------------------------------------------------------------I N I T----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------BEGIN INITIALISATION-------------------------------------------------------------------------------

#---------------------------------------------------------------------------variables--------------------------------------------------------------------------------------------------
# word-specific values
var value[] = [87, 73, 84, 72] 			# the ASCII code every letter of the word as an array - 'with'
var class = 11								# category - preposition  in this case
var coreclass = 1			# if the class is the core of a phrase

# grammaticality judgements
var maxclass = class	# maximal phrase category achieved, e.g. NP, VP, construction etc.
var phraseID = 0			# id of the phrase containing the word
var phrasetype = 103	# type of the phrase corresponding to the phraseID
var oldphraseID = 0	# if superceding phrase, used to notify all other members of the same phrase
var phraseComplete = 0	# if the phrase is complete
var constructionComplete = 0	# if the whole construction is complete
#var phraseIDsInPhrase[4]	# where the IDs of all absorbed phrases are stored
var highestpid = 0	# highest phraseID below the current robot
var phrasestart = -1
var phraseend = -1
var phrasecore = -1
var updateComplete = 1
var upscalable = 0		# is another increment possible?
var updateSuccessful = 0
var higherPhrase = 0	# does the robot belong to another phrase
var cu = 0		# keep sending out checkupdate events?
var bl = 0			# keep sending out the block event?
var lastPhraseAddition = 0	# ID of the core of the last phrase added
var next = 0	# boolean to check if the checkupdate should send the prhasestart or phraseend


# storage variables
var consPossible[4] = [1,1,0,0]
var ppPossible[] = [1,0,0]
var ppLengths [] = [2,2,3]

# general variables
var id = 0 					# the communication ID. Corresponds to the number of the robot in the line starting from the backhigh
var oldid = 0				# to check if there has been a change in the order
var pid = 0					# underlying phrase id
var oldpid = 0				# to check if there has been a change in the pid

# aux variables
#var prevback = 0
#var prevfront = 0
var bool = 0
var i = 0
var j = 0

# completion check variables
var pp0comp[] = [class,0]
var pp1comp[] = [103,0]
var pp2comp[] = [103,0,0]

#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------functions----------------------------------------------------------------------------------------------------

# resetting the leds so that no previous colour setting interferes
call leds.top(0,0,0)

# enabling communication
call prox.comm.enable(1)

#----------------------------------------------------------------------------END INITIALISATION----------------------------------------------------------------------------------

onevent prox	
	
	oldid = id
	oldpid = pid
	
	# call the subroutine to establish the IDs
	if id == 0 and ((prox.horizontal[5] < 10 and prox.horizontal[5] > -10) or (prox.horizontal[6] < 10 and prox.horizontal[6] > -10)) and (prox.horizontal[2] > 10 or prox.horizontal[2] < -10) then
		id = 1
		# send out the robot's ID
		prox.comm.tx = id
	# if ID != 1 and no neighbours behind or if ID == 1 and neighbours behind, re-establish the IDs
	elseif( id != 1 and ((prox.horizontal[5] < 10 and prox.horizontal[5] > -10) or (prox.horizontal[6] < 10 and prox.horizontal[6] > -10)) and (prox.horizontal[2] > 10 or prox.horizontal[2] < -10)) then
		id = 1
		emit recountID
		callsub reset
	end
	
	if pid == 0 and ((prox.horizontal[5] < 10 and prox.horizontal[5] > -10) or (prox.horizontal[6] < 10 and prox.horizontal[6] > -10)) and (prox.horizontal[2] > 10 or prox.horizontal[2] < -10) then
		if class != 1 and class != 10 and class != 12 and class != 14 then
			pid = 1
			highestpid = 1
			emit neighbour_value [id, pid]
		else
			pid = -2
			emit neighbour_value [id, 0]			
		end
	else
		emit neighbour_value [id, highestpid]
	end	
		
	if higherPhrase != 1  then
		phraseID = pid
		if coreclass == 1 then
			phrasestart = id
			phraseend = id
		else
			phrasestart = -1
			phraseend = -1
		end
	end
		
	#TODO what I need
	if id != 0 and phraseID != 0 and (maxclass == class) and upscalable == 0 then
			emit searchNextCompletion [id, phraseID, phraseend, 	phrasetype]
	end
	#TODO end
	
	if cu == 1 or updateComplete == 0 then
		#call sound.system(7)
		if next == 1 and (phraseend != -1 and phraseend != 0) then
			emit checkUpdate [id, phrasecore, maxclass, phraseend]
		elseif next == 1 then
			emit checkUpdate [id, phrasecore, maxclass, id]
		elseif (phrasestart != -1 and phrasestart != 0) then
			emit checkUpdate [id, phrasecore, maxclass, phrasestart]
		else
			emit checkUpdate [id, phrasecore, maxclass, id]
		end
	end
	
	if updateSuccessful == 1  and lastPhraseAddition != 0 then
		emit successfulUpdateConfirmation [id, lastPhraseAddition, phraseID, phrasetype, phraseComplete, upscalable]
	end
	
	if bl == 1 then
		emit block [id, phrasecore, maxclass]
	end
	
	if oldphraseID != phraseID and oldphraseID > 0 then
		emit supercede [id, oldphraseID, phraseID, phrasetype, phraseComplete, upscalable]
	end
	

	if phraseComplete == 1 then
		#maxclass = phrasetype
		emit phraseComplete [phraseID, upscalable, phrasetype, phrasestart, phraseend]
	else
		upscalable = 0
	end
	
	if phraseID <= 0 or (phrasestart == id and phraseend == id) then
		phraseComplete = 0
	end
	
	# if there are no neighbours, set colour to white
	if (prox.horizontal[2] < 10 and prox.horizontal[2] > -10)  and ((prox.horizontal[5] < 10 and prox.horizontal[6] > -10) or (prox.horizontal[6] < 10 and prox.horizontal[6] > -10)) then
		id = 0
		phraseID = 0
		upscalable = 0
		call leds.top(32,32,32)
		callsub reset
	elseif constructionComplete == 1 then
		call leds.top(0,32,0)
	elseif phraseComplete == 1 then
		call leds.top(32,32,0)
	elseif id != 0 then
		call leds.top(32,0,0)
	else
		call leds.top(32,32,32)
	end


#-----------------------------------------------------------------------C O M M U N I C A T I O N----------------------------------------------------------------------------------
#-----------------------------------------------------------------------BOTTOM LAYER COMMUNICATION------------------------------------------------------------------------
# BOTTOM LAYER COMMUNICATION

onevent prox.comm
	# if the robot does not have an ID yet and it receives a message, it increments the senderID and stores it as its own
	if  id == 0 and prox.comm.rx != 0 and ((prox.horizontal[5] > 10 or prox.horizontal[5] < -10) or (prox.horizontal[6] > 10 or prox.horizontal[6] < -10)) then
		id = prox.comm.rx + 1
		# send out the robot's ID
		prox.comm.tx = id
	# if the robot has an ID but receives an unexpected ID, the IDs need to be re-established as it is likely that the order has changed
	elseif id != 0 and prox.comm.rx != (id-1) and prox.comm.rx != (id+1) and prox.comm.rx != 0 then
		if id != 1 or ((prox.horizontal[5] > 10 or prox.horizontal[5] < -10) or (prox.horizontal[6] > 10 and prox.horizontal[6] < -10)) then
			id = 0
		end
		prox.comm.tx = id
		emit recountID
		callsub reset
	end
	
# set ID back to 0 and pass the message on
onevent recountID
	pid = 0
	if ((prox.horizontal[5] < 10 and prox.horizontal[5] > -10) or (prox.horizontal[6] < 10 and prox.horizontal[6] > -10)) and (prox.horizontal[2] > 10 or prox.horizontal[2] < -10) then
		if id != 1 then
			id = 1
			# send out the robot's ID
			prox.comm.tx = id
		end

	elseif  id > 1 then
		id = 0
		# send out the robot's ID
		prox.comm.tx = id
	end
	callsub reset

#-------------------------------------------------------------------------TOP LAYER COMMUNICATION--------------------------------------------------------------------------------
# TOP LAYER COMMUNICATION


# neighbour_value [id{0}, maxphraseid{1}]
onevent neighbour_value
	if id == event.args[0]+1 then
		if class != 1 and class != 10 and class != 12 and class != 14 then
			pid = event.args[1] + 1
			highestpid = pid
			emit neighbour_value [id, pid]
		else
			pid = -2
			highestpid = event.args[1]
			emit neighbour_value [id, highestpid]
		end	
	end
	
#-----------------------------------------------------------------G R A M M A T I C A L I T Y    J U D G E M E N T S----------------------------------------------------------------
#-----------------------------------------------------------------SEARCH EVENTS------------------------------------------------------------------------------------------------------
# adjectives on their own can only be part of an ADJP and they will be the core of that phrase. If they already form an ADJP, they can only become part of another ADJP, a NP or a VP. In all other cases, the adjective notifies the sender that there will not be a completion including the adjective.
#	emit searchNextCompletion [id{0}, phraseID{1}, phraseend{2}, 	phrasetype{3}]

onevent searchNextCompletion
	if  phraseID != event.args[1] and maxclass == 103 and upscalable == 1 and  updateComplete == 1 and (event.args[3] == 102)  and event.args[2] == id-1 then
		cu = 0
		bl = 0
		next = 1
		phrasecore = event.args[0]
		updateComplete = 0
		if phraseend != -1 and phraseend != 0 then
			emit checkUpdate [id, phrasecore, maxclass, phraseend]
		else
			emit checkUpdate [id, phrasecore, maxclass, id]
		end
	elseif phraseID != event.args[1] and upscalable == 1 and event.args[2] == id-1 and  ( event.args[3] != 102) then
		phrasecore = event.args[0]
		bl = 1
		emit block [id, phrasecore, maxclass]
	end

onevent searchPrevCompletion
	if  phraseID != event.args[1] and maxclass > 99 and upscalable == 1 and  updateComplete == 1 and (event.args[3] ==  102)  and event.args[2] == id+1 then
		emit searchPrevCompletion [event.args[0], event.args[1], id, event.args[3]]
	end

#----------------------------------------------------------------UPDATES----------------------------------------------------------------------------------------------------------------
# if a robot sends back a message, the robot checks if the new value should be included in the phrase
#var ppPossible[] = [1,0,0]
#var ppLengths [] = [2,2,3]
#
## completion check variables
#var pp0comp[] = [class,0]
#var pp1comp[] = [103,0]
#var pp2comp[] = [103,0,0]
#
## PPs: 103
#var pp0[] = [11,101]	# P + NP
#var pp1[] = [103,103]	# PP + PP
#var pp2[] = [103,14,103]	# PP + CONJ + PP

#	emit checkUpdate [id{0}, phrasecore{1}, maxclass{2}, phraseend{3}]
onevent checkUpdate
	if event.args[0] == phraseend + 1 then
		updateSuccessful = 0
		if event.args[2] == 101 and ppPossible[0] == 1 then
			pp0comp[1] = 101
			ppPossible[1] = 0
			ppPossible[2] = 0
			phraseComplete = 1
			upscalable = 1
			updateSuccessful = 1
		elseif event.args[2] == 14 and ppPossible[2] == 1 and pp2comp[1] == 0  then
			pp2comp[1] = 1
			ppPossible[0] = 0
			ppPossible[1] = 0
			phraseComplete = 0
			upscalable = 0
			updateSuccessful = 1		
		elseif event.args[2] == 103 and ((ppPossible[1] == 1 and pp1comp[1] == 0) or (ppPossible[2] == 1 and pp2comp[1] == 14 and pp2comp[2] == 0)) then
			ppPossible[0] = 0
			pp1comp[1] = 103
			pp2comp[2] = 103
			phraseComplete = 1
			upscalable = 1
			updateSuccessful = 1
		end
		if updateSuccessful == 1 then
			higherPhrase = 1
			phraseend = event.args[3]
			lastPhraseAddition = event.args[0]
			emit successfulUpdateConfirmation [id, event.args[0], phraseID, phrasetype, phraseComplete, upscalable]
			if phraseComplete == 1 then
				maxclass = phrasetype
				emit phraseComplete [phraseID, upscalable, phrasetype, phrasestart, phraseend]
			end
		else
			if phraseComplete == 1 then
				upscalable = 1
				maxclass = phrasetype
				ppPossible = [0,1,1]
			else
				upscalable = 0
			end
			emit updateDeclination [id, event.args[0]]
		end
	end

# if the robot's phrase is absorbed, the supercede event informs it of the update
# emit supercede [id{0}, oldphraseID{1}, phraseID{2}, phrasetype{3}, phraseComplete{4}, upscalable{5}]
onevent supercede
	if event.args[1] == phraseID then
		oldphraseID = phraseID
		phraseID = event.args[2]
		phrasetype = event.args[3]
		if event.args[4] == 1 then
			phraseComplete = 1
			maxclass = phrasetype
		else
			phraseComplete = 0
		end
		if event.args[5] == 1 then
			upscalable = 1
		else
			upscalable = 0
		end
	end
	
# emit phraseComplete [phraseID, upscalable]
onevent phraseComplete
	if event.args[0] == phraseID then
		phraseComplete = 1
		upscalable = event.args[1]
	end
	
# emit constructionComplete [phraseID]
onevent constructionComplete
	if event.args[0] == phraseID then
		constructionComplete = 1
		upscalable = 1
	end

#	emit block [id, phrasecore, maxclass]	
onevent block
	if event.args[1] == id and event.args[0] == phraseend + 1 then
		if phraseComplete == 1 then
			upscalable = 1
			maxclass = phrasetype
		else
			upscalable = 0
		end
	end
	
#-------------------------------------------------------------RESPONSES------------------------------------------------------------------------------------------------------------------
#	emit successfulUpdateConfirmation [id{0}, event.args[0]{1}, phraseID{2}, phrasetype{3}, phraseComplete{4}, upscalable{5}]
# if the phrasecore confirms the update, the robot updates its own data
onevent successfulUpdateConfirmation
	if event.args[0] == phrasecore and event.args[1] == id and phraseID != event.args[2] then
		cu = 0
		bl = 0
		higherPhrase = 1
		updateComplete = 1
		oldphraseID = phraseID
		phraseID = event.args[2]
		phrasetype = event.args[3]
		if event.args[4] == 1 then
			phraseComplete = 1
			maxclass = event.args[3]
		else
			phraseComplete = 0
		end
		if event.args[5] == 1 then
			upscalable = 1
		else
			upscalable = 0
		end
		emit supercede [id, oldphraseID, phraseID, phrasetype, phraseComplete, upscalable]
	end

#if the phrasecore declines the update, the robot switches back into considering other search events
#	emit updateDeclination [senderid, targetid]
onevent updateDeclination
	if event.args[0] == phrasecore and event.args[1] == id then
		cu = 0
		phrasecore = 0
		updateComplete = 1
	end
	
#----------------------------------------------------------------R E S E T T I N G-----------------------------------------------------------------------------------------------------
sub reset
	ppPossible = [1,0,0]	
	ppLengths  = [2,2,3]
	pp0comp = [class,0]
	pp1comp = [103,0]
	pp2comp = [103,0,0]
	consPossible = [1,1,0,0]
	constructionComplete = 0
	phraseComplete = 0
	updateSuccessful = 0
	cu = 0
	maxclass = class
	phraseID = 0
	oldpid = 0
	oldid = 0
	highestpid = 0
	pid = 0
	phrasetype = 103		# type of the phrase corresponding to the phraseID	
	oldphraseID = 0
	upscalable = 0
	phrasestart = 0
	phraseend = 0
	phrasecore = 0
	higherPhrase = 0
	updateComplete = 1
	bl = 0