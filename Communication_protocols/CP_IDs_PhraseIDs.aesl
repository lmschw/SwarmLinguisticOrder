# this file contains the communication protocol for all the grammar applications, i.e. how the robots determine their place in the line

# Setup: 
#		1) create the 4 events:
# 		i) idModeSwitch (1 arg: mode)
#			ii) neighbour_value (2 args: id, phraseid)
#			iii) recountID
#			iv) recountPhraseID
#		2) change colour for disambiguation
#		3) if necessary, change the value and the class to switch word

#----------------------------------------------------------------------------I N I T----------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------BEGIN INITIALISATION-------------------------------------------------------------------------------

#---------------------------------------------------------------------------variables--------------------------------------------------------------------------------------------------
# word-specific values
var value[] = [84,73,69] 			# the ASCII code every letter of the word as an array - 'the'
var class = 8								# category - determiner in this case

# communication variables
var maximalPID= 0		# the highest phrase ID, i.e. the number of phrases that have been constructed
var phraseid = 0			# id of the phrase containing the word
var idpid = 0 # 0 when establishing IDs, 1 when establishing phraseIDs
var highestpid = 0	# highest phraseID below the current robot

# general variables
var id = 0 					# the communication ID. Corresponds to the number of the robot in the line starting from the back

#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------functions----------------------------------------------------------------------------------------------------

# resetting the leds so that no previous colour setting interferes
call leds.top(0,0,0)

# enabling communication
call prox.comm.enable(1)

#----------------------------------------------------------------------------END INITIALISATION----------------------------------------------------------------------------------
# handles what happens when the buttons are pressed
onevent buttons
	# while the forward button is pressed, the robot will show a colour. Different colours can be used if the robots need to be disambiguated.
	if (button.forward == 1) then
		call leds.top(32,12,32) #purple: use different colour for every robot to disambiguate
	end
	# if the backward button is pressed, the robot stops moving. Safety measure in case the robot runs off or is at risk
	if button.backward == 1 then
		motor.left.target = 0
		motor.right.target = 0
	end

# this event is launched regularly, therefore its contents are also checked and executed at a regular frequency
onevent prox
	# in phrase configuration mode, any robot that has an ID of 0 has not yet been included in the line and the IDs need to be reestablished before the phraseIDs can be established
	if idpid ==1 then
		if id == 0 then
			idpid = 0
			emit recountID
			callsub comm
		# if the ID has been established but the phraseID not yet, all robots with a word that is the core of a phrase calls the 'comm' subroutine
		elseif phraseid == 0 and  class != 1 and class != 10 and class != 12 then
			callsub comm
		# for words of classes 1, 10 and 12 as well as robots that already have a phraseID, the ID and the PhraseID are transmitted to other robots
		else
			if phraseid > 0 then
				emit neighbour_value [id, phraseid]
			elseif  phraseid == -2 then
				emit neighbour_value [id, highestpid]
			end
		end
	end
	# if there are no neighbours, the ID, the phraseID and the mode are reset to 0
	if prox.horizontal[2] == 0 and prox.horizontal[5] == 0 and prox.horizontal[6] == 0 then
		idpid = 0
		id = 0
		phraseid = 0
	# if there is only a neighbour in front and the robot was not previously the first robot in the line, the IDs are reestablished
	elseif prox.horizontal[5] == 0 and prox.horizontal[6] == 0 and id != 1 then
		emit recountID
		callsub comm
	elseif  prox.horizontal[5] == 0 and prox.horizontal[6] == 0 and (phraseid != 1 and phraseid != -2) then
		if class != 1 and class != 10 and class != 12  then
			phraseid = 1
			emit recountPhraseID
		else
			phraseid = -2
			emit recountPhraseID
		end
	# if there is no robot in front but a neighbour at the back, the mode is switched and the other robots are alerted to do the same.
	elseif prox.horizontal[2] == 0 then
		if idpid == 0 and id != 0 then
			idpid = 1
			emit idModeSwitch idpid
		elseif idpid == 1 and phraseid >= 0 then
			idpid = 0
			emit idModeSwitch idpid
		end
	end
	
	# if the robot does not have an ID, enforces ID search. Else, checks if the robot is at the centre of a phrase or not.
	if idpid == 0 then
		if id == 0 then
			callsub comm
		end
	end

# only does something if the robot is the first robot in the line, i.e. does not have a neighbour behind it
sub comm
	if prox.horizontal[2] > 2000 and (prox.horizontal[5] == 0 or prox.horizontal[6] == 0) then
		# if the IDs are being established, the ID of the last robot is 1 and it starts broadcasting its ID
		if idpid == 0 then
			id = 1
			prox.comm.tx = id

		# if the PhraseIDs are being established, the PhraseID of the last robot is 1 and it starts broadcasting its PhraseID
		elseif  idpid == 1 then
			phraseid = 1
			emit neighbour_value [id, phraseid]
			emit recountPhraseID
		end
	elseif  idpid == 0 then
		id = 0
	elseif  idpid ==1 then
		phraseid = 0
	end

# switches between the two modes: establishing IDs and establishing phraseIDs
onevent idModeSwitch
	if event.args[0] == 0 and (phraseid == -1 or phraseid == 0) then
		idpid = 1
		if class != 1 and class != 10 and class != 12 then
			callsub comm
		else
			callsub comm
		end
	elseif event.args[0] == 1 and id == 0 then
		emit recountID
		idpid = 0
	else
		idpid = event.args[0]
	end

onevent prox.comm
	# when establishing the IDs, the robot takes the value it receives as the ID of its predecessor and increments it for its own ID. Then, it broadcasts its own ID
	if idpid == 0 then
		if id == 0 and prox.comm.rx != 0 then
			id = prox.comm.rx + 1
			prox.comm.tx = id
		elseif id != prox.comm.rx -1 and id != prox.comm.rx +1 then
			emit recountID
		end
	end
	
# if the sender is the robot's predecessor, the phraseID is updated. Otherwise, if the order of phraseIDs and IDs don't correspond, the phraseIDs are reestablished.
onevent neighbour_value
	if event.args[0] == id -1 then
		if phraseid == 0 and  class != 1 and class != 10 and class != 12 then
			phraseid = event.args[1] + 1
			emit neighbour_value [id, phraseid]
		elseif phraseid == 0 then
			phraseid = -2
			emit neighbour_value[id, event.args[1]]
			highestpid = event.args[1]
		end
	elseif (event.args[0] < id and event.args[1] > phraseid) and (event.args[0] > id and event.args[1] < phraseid) then
		emit recountPhraseID
	end
	
# notifies robots that the IDs need to be reestablished
onevent recountID # takes 0 arguments
	idpid = 0
	callsub comm

# notifies robots that the IDs need to be reestablished	
onevent recountPhraseID
	phraseid = 0
	idpid = 1
	callsub comm